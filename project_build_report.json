{
  "plan": [
    {
      "task_prompt": "Create a standard Python .gitignore file. It should ignore common Python artifacts like __pycache__, .venv, virtual environments, .env files, and IDE-specific folders like .idea/ and .vscode/. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": ".gitignore",
      "model": "local"
    },
    {
      "task_prompt": "Create a requirements.txt file listing the Python package dependencies. The file must only contain the package names, without any version pinning. The required packages are: 'fastapi', 'uvicorn[standard]', 'sqlalchemy', 'psycopg2-binary', 'python-dotenv', 'pydantic-settings', 'passlib[bcrypt]', 'python-multipart'. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "requirements.txt",
      "model": "local"
    },
    {
      "task_prompt": "Create an example environment file named '.env.example'. It should contain the key 'DATABASE_URL' with the example value 'postgresql+psycopg2://user:password@localhost/dbname'. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": ".env.example",
      "model": "local"
    },
    {
      "task_prompt": "Create the content for the '.env' file. It must contain the single key 'DATABASE_URL' set to the exact value 'postgresql+psycopg2://myuser:mypassword@db/mydatabase'. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": ".env",
      "model": "local"
    },
    {
      "task_prompt": "Create a multi-stage Dockerfile for a Python FastAPI application. Use 'python:3.11-slim' as the base image. The first stage should install poetry and dependencies. The second stage should copy the installed dependencies and the application code from the 'app' directory into '/app'. The working directory should be '/app'. Install dependencies from 'requirements.txt'. The final command should run the application using uvicorn on host 0.0.0.0 and port 8000, with the entrypoint being 'app.main:app'. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "Dockerfile",
      "model": "local"
    },
    {
      "task_prompt": "Create a docker-compose.yml file using version '3.8'. It must define two services: 'db' and 'api'. The 'db' service should use the 'timescale/timescaledb:latest-pg14' image, have a volume named 'postgres_data', and set the POSTGRES_USER, POSTGRES_PASSWORD, and POSTGRES_DB to 'myuser', 'mypassword', and 'mydatabase' respectively. The 'api' service should build from the current directory's Dockerfile, map port 8000 to 8000, have a volume mapping './app' to '/app', depend on the 'db' service, and use the '.env' file. Ensure all indentation uses 2 spaces. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "docker-compose.yml",
      "model": "local"
    },
    {
      "task_prompt": "Create the 'app/database.py' file. It must use 'python-dotenv' to load environment variables at the very top. It should then import necessary components from sqlalchemy and os. Define the 'DATABASE_URL' by getting it from the environment. Create a SQLAlchemy engine and a SessionLocal class using 'sessionmaker'. Finally, define a 'Base' declarative base class. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/database.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/models.py' file. Define 6 SQLAlchemy models corresponding to the database schema. Use relative imports to get 'Base' from '.database'. Import types like Integer, String, Column, ForeignKey, DateTime, JSONB (from sqlalchemy.dialects.postgresql). The tables are: 1. 'organizations': id (PK), name (String, unique), api_key_hash (String, unique). 2. 'models': id (PK), organization_id (FK to organizations.id), name (String), model_type (String), baseline_mean (Float), baseline_std (Float). 3. 'model_features': id (PK), model_id (FK to models.id), feature_name (String), feature_type (String), baseline_stats (JSONB). 4. 'predictions': id (PK), time (DateTime(timezone=True), server_default=func.now()), model_id (FK to models.id), prediction_value (Float), features (JSONB). 5. 'drift_alerts': id (PK), model_id (FK to models.id), alert_type (String), drift_score (Float), created_at (DateTime(timezone=True), server_default=func.now()). 6. 'alert_channels': id (PK), organization_id (FK to organizations.id), channel_type (String, e.g., 'email', 'webhook'), configuration (JSONB). Use relationships where appropriate. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/models.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/schemas.py' file. Define Pydantic V2 models for API data validation and serialization. Create schemas for each of the 6 database models. For each entity (e.g., Organization, Model, Prediction), create a 'Base' schema with common fields, a 'Create' schema inheriting from 'Base' for input, and a 'Read' schema inheriting from 'Base' that includes fields like 'id' for output. All 'Read' schemas must include `model_config = {\"from_attributes\": True}` to enable ORM mode. For 'OrganizationCreate', expect a 'name'; for 'Organization', include 'id' and 'name' but not the API key hash. Create a special schema 'OrganizationWithAPIKey' that includes the 'api_key'. Make sure schemas for related models are nested correctly (e.g., a full 'Model' schema might include its list of 'ModelFeature' schemas). Use standard Python types and `datetime` and `UUID` where appropriate. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/schemas.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/security.py' file. It should contain functions for handling API key authentication. Import necessary modules: 'secrets', 'passlib.context', 'fastapi', 'fastapi.security', 'sqlalchemy.orm'. Use relative imports for '.crud' and '.database'. Create a 'PwdContext' for 'bcrypt'. Define a function 'get_password_hash'. Define a function 'create_api_key' that returns a new secure token. Define a dependency function 'get_db' for database sessions. Define an 'APIKeyHeader' security scheme for the 'X-API-Key' header. Create a main dependency function 'verify_api_key' that takes the API key from the header, looks up the organization by that key's hash in the database (using a crud function), and raises an HTTP 403 exception if not found or invalid. This function should return the organization object if valid. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/security.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/crud.py' file. This file will contain all the database interaction functions. Import 'Session' from 'sqlalchemy.orm' and use relative imports for '.models' and '.schemas'. Create functions to: 1. `get_organization_by_api_key_hash(db: Session, api_key_hash: str)`: Fetches an organization by its hashed API key. 2. `create_organization(db: Session, organization: schemas.OrganizationCreate, api_key_hash: str)`: Creates a new organization. 3. `get_models(db: Session, organization_id: int, skip: int, limit: int)`: Lists models for an organization. 4. `create_model(db: Session, model: schemas.ModelCreate, organization_id: int)`: Creates a new model for an organization. 5. `create_prediction(db: Session, prediction: schemas.PredictionCreate, model_id: int)`: Adds a new prediction record for a model. 6. `get_latest_predictions(db: Session, model_id: int, limit: int)`: Gets the most recent predictions for a model. All create functions should create the model instance, add it to the session, commit, and refresh. All get functions should query the database and return the results. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/crud.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/api/auth.py' router file. Import 'APIRouter', 'Depends', and 'HTTPException' from 'fastapi', and 'Session' from 'sqlalchemy.orm'. Use relative imports to bring in '.security', '.crud', and '.schemas'. Create an 'APIRouter' instance. Define a single endpoint: 'POST /register' which takes a 'schemas.OrganizationCreate' as input. Inside the endpoint, generate a new API key and its hash using functions from the security module. Create the organization in the database using the crud function. Return a 'schemas.OrganizationWithAPIKey' containing the organization's info and the newly generated (non-hashed) API key. This is the only time the client will see the raw key. Use 'get_db' as a dependency. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/api/auth.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/api/models.py' router file. Import 'APIRouter', 'Depends', 'List' from FastAPI and 'Session' from sqlalchemy.orm. Use relative imports for '.security', '.crud', '.schemas', and '.models'. Create an 'APIRouter'. Define two endpoints, both protected by the 'verify_api_key' dependency. 1. 'POST /', which takes a 'schemas.ModelCreate' object, uses the authenticated organization from the dependency, and calls the 'create_model' crud function. It should return the newly created model using the 'schemas.Model' schema. 2. 'GET /', which uses the authenticated organization, calls the 'get_models' crud function with default pagination, and returns a list of models using 'List[schemas.Model]'. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/api/models.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/api/predictions.py' router file. Import 'APIRouter', 'Depends' from FastAPI and 'Session' from sqlalchemy.orm. Use relative imports for '.security', '.crud', and '.schemas'. Create an 'APIRouter'. Define one endpoint: 'POST /models/{model_id}/predictions', protected by the 'verify_api_key' dependency. It should take a 'model_id' from the path and a 'schemas.PredictionCreate' object from the body. You should also add a check to ensure the model being posted to belongs to the authenticated organization. Call the 'create_prediction' crud function. Return the created prediction using the 'schemas.Prediction' schema. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/api/predictions.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the 'app/api/drift.py' router file. Import 'APIRouter', 'Depends' from FastAPI and 'Session' from sqlalchemy.orm. Use relative imports for '.security' and '.crud'. Create an 'APIRouter'. Define one endpoint: 'GET /models/{model_id}/drift/current', protected by the 'verify_api_key' dependency. It takes a 'model_id' from the path. For this MVP, the logic will be simple: fetch the 100 most recent predictions using a crud function. Calculate the mean of these predictions. Compare it to the model's 'baseline_mean'. Return a JSON response like `{\"current_mean\": ..., \"baseline_mean\": ..., \"drift_detected\": ...}`. The drift logic can be a simple placeholder, e.g., drift is detected if the current mean deviates by more than 2 standard deviations from the baseline. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/api/drift.py",
      "model": "gemini"
    },
    {
      "task_prompt": "Create the main application file 'app/main.py'. Import 'FastAPI'. Use relative imports to bring in the routers from 'app.api.auth', 'app.api.models', 'app.api.predictions', and 'app.api.drift'. Also import 'Base' and 'engine' from 'app.database'. Create the main 'FastAPI' app instance. Add a startup event handler using '@app.on_event(\"startup\")' that calls 'Base.metadata.create_all(bind=engine)' to create the database tables. Include the routers using 'app.include_router', setting appropriate prefixes (e.g., '/auth', '/models') and tags. Add a root endpoint 'GET /' that returns a simple welcome message like `{\"message\": \"DriftGuard AI is running\"}`. CRITICAL: Your response MUST be only the raw, valid, uncommented code for the file. Start with the first line of code and end with the last. Do not include *any* descriptive text, explanations, or markdown formatting.",
      "output_file": "app/main.py",
      "model": "gemini"
    }
  ],
  "generated_files": [
    ".gitignore",
    "requirements.txt",
    ".env.example",
    ".env",
    "Dockerfile",
    "docker-compose.yml",
    "app/database.py",
    "app/models.py",
    "app/schemas.py",
    "app/security.py",
    "app/crud.py",
    "app/api/auth.py",
    "app/api/models.py",
    "app/api/predictions.py",
    "app/api/drift.py",
    "app/main.py"
  ],
  "architecture": {},
  "errors": []
}